/*
 * Copyright Siemens AG, 2021. Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.clients.rest;

import static com.github.tomakehurst.wiremock.client.WireMock.delete;
import static com.github.tomakehurst.wiremock.client.WireMock.equalToJson;
import static com.github.tomakehurst.wiremock.client.WireMock.get;
import static com.github.tomakehurst.wiremock.client.WireMock.patch;
import static com.github.tomakehurst.wiremock.client.WireMock.post;
import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;
import static com.github.tomakehurst.wiremock.client.WireMock.urlPathEqualTo;
import static org.assertj.core.api.Assertions.assertThat;
import static org.eclipse.sw360.http.utils.HttpUtils.waitFor;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.CompletableFuture;

import org.eclipse.sw360.clients.adapter.SW360ComponentClientAdapterAsync;
import org.eclipse.sw360.clients.adapter.SW360ConnectionFactory;
import org.eclipse.sw360.clients.adapter.SW360LicenseClientAdapterAsync;
import org.eclipse.sw360.clients.adapter.SW360ReleaseClientAdapterAsync;
import org.eclipse.sw360.clients.adapter.SW360VulnerabilityClientAdapterAsync;
import org.eclipse.sw360.clients.rest.resource.SW360HalResource;
import org.eclipse.sw360.clients.rest.resource.components.SW360Component;
import org.eclipse.sw360.clients.rest.resource.releases.SW360Release;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360ReleaseVulnerabilityRelation;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360Vulnerability;
import org.eclipse.sw360.http.utils.HttpConstants;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class SW360VulnerabilityClientIT extends AbstractMockServerTest {
    private static final String UPDATED_TITLE_OF_VULNERABILITY = "Updated Title of vulnerability";
    private static final String EXTERNAL_ID = "test987";
    private SW360VulnerabilityClient vulnerabilityClient;
    private SW360ReleaseClient releaseClient;
    private SW360ComponentClient componentClient;
    @Before
    public void setUp() throws IOException {
        if (RUN_REST_INTEGRATION_TEST) {
            SW360ConnectionFactory scf = new SW360ConnectionFactory();
            SW360VulnerabilityClientAdapterAsync vulnerabilityClientAsync = scf.newConnection(createClientConfig())
                    .getVulnerabilityAdapterAsync();
            vulnerabilityClient = vulnerabilityClientAsync.getVulnerabilityClient();
            SW360ReleaseClientAdapterAsync releaseClientAsync = scf.newConnection(createClientConfig())
                    .getReleaseAdapterAsync();
            SW360ComponentClientAdapterAsync componentClientAsync = scf.newConnection(createClientConfig())
                    .getComponentAdapterAsync();
            componentClient = componentClientAsync.getComponentClient();
            releaseClient = releaseClientAsync.getReleaseClient();
        } else {
            vulnerabilityClient = new SW360VulnerabilityClient(createClientConfig(), createMockTokenProvider());
            prepareAccessTokens(vulnerabilityClient.getTokenProvider(), CompletableFuture.completedFuture(ACCESS_TOKEN));
        }
        cleanUp();
        createVulnerability();
    }

    @Test()
    public void testCreateVulnerability() throws IOException {
    }

    @Test
    public void testPatchVulnerability() throws IOException {
        SW360Vulnerability vulnerability = readTestJsonFile(resolveTestFileURL("vulnerability.json"),
                SW360Vulnerability.class);
        vulnerability.setTitle(UPDATED_TITLE_OF_VULNERABILITY);
        String vulnerabilityJson = toJson(vulnerability);
        wireMockRule.stubFor(patch(urlEqualTo("/vulnerabilities/" + vulnerability.getExternalId()))
                .withRequestBody(equalToJson(vulnerabilityJson))
                .willReturn(aJsonResponse(HttpConstants.STATUS_ACCEPTED).withBody(vulnerabilityJson)));

        SW360Vulnerability patchedvulnerability = waitFor(
                vulnerabilityClient.patchVulnerability(vulnerability, vulnerability.getExternalId()));
        assertThat(patchedvulnerability).isEqualTo(vulnerability);

    }

    @Test
    public void testGetVulnerability() throws IOException {
        wireMockRule.stubFor(get(urlPathEqualTo("/vulnerabilities/" + EXTERNAL_ID))
                .willReturn(aJsonResponse(HttpConstants.STATUS_OK).withBodyFile("vulnerability.json")));

        SW360Vulnerability vulnerability = waitFor(vulnerabilityClient.getVulnerabilityByExternalId(EXTERNAL_ID));
        assertThat(vulnerability.getDescription()).isEqualTo("Description of vulnerability");
        assertThat(vulnerability.getPriorityText()).isEqualTo("Priority Text");
    }

    @Test
    public void testGetAllVulnerability() throws IOException {
        wireMockRule.stubFor(get(urlPathEqualTo("/vulnerabilities"))
                .willReturn(aJsonResponse(HttpConstants.STATUS_OK).withBodyFile("all_vulnerabilities.json")));

        List<SW360Vulnerability> vulnerabilities = waitFor(vulnerabilityClient.getVulnerabilities());

        assertThat(vulnerabilities.size()).isGreaterThan(0);

        Optional<SW360Vulnerability> vulToTest = vulnerabilities.stream()
                .filter(vl -> vl.getExternalId().equals(EXTERNAL_ID)).findFirst();

        assertThat(vulToTest).isPresent();
        assertThat(vulToTest.get().getTitle()).isEqualTo("Title of vulnerability 12345");

    }

    @Test
    public void testCreateReleaseVulnerabilityRelation() throws IOException {
        List<SW360HalResource> compReleaseList = createVulnerabilityReleaseRelation();
        if (RUN_REST_INTEGRATION_TEST) {
            cleanUpVulnerabilityReleaseRealtion();
            SW360ReleaseClientIT.cleanupRelease((SW360Release)compReleaseList.get(1), releaseClient);
            SW360ReleaseClientIT.cleanupComponent(componentClient);
        }
    }

    @Test
    public void testDeleteReleaseVulnerabilityRelation() throws IOException {
        List<SW360HalResource> compReleaseList = createVulnerabilityReleaseRelation();
        wireMockRule.stubFor(delete(urlPathEqualTo("/vulnerabilities/" + EXTERNAL_ID + "/release/1234"))
                .willReturn(aJsonResponse(HttpConstants.STATUS_MULTI_STATUS).withBodyFile("delete_vulnerability_release_relation.json")));
        MultiStatusResponse responseCode = waitFor(vulnerabilityClient.deleteVulnerabilityReleaseRelation(EXTERNAL_ID,
                RUN_REST_INTEGRATION_TEST ? ((SW360Release) compReleaseList.get(1)).getId() : "1234"));
        assertThat(responseCode.getStatus(EXTERNAL_ID + " - " + (RUN_REST_INTEGRATION_TEST ? ((SW360Release) compReleaseList.get(1)).getId() : "1234"))).isEqualTo(200);

        if (RUN_REST_INTEGRATION_TEST) {
            SW360ReleaseClientIT.cleanupRelease((SW360Release)compReleaseList.get(1), releaseClient);
            SW360ReleaseClientIT.cleanupComponent(componentClient);
        }
    }

    @Test
    public void testDeleteVulnerability() {
        wireMockRule.stubFor(delete(urlPathEqualTo("/vulnerabilities/" + EXTERNAL_ID))
                .willReturn(aJsonResponse(HttpConstants.STATUS_MULTI_STATUS)));
    }

    private void createVulnerability() throws IOException {
        SW360Vulnerability vulnerability = readTestJsonFile(resolveTestFileURL("vulnerability.json"),
                SW360Vulnerability.class);
        String vulnerabilityJson = toJson(vulnerability);
        wireMockRule.stubFor(post(urlEqualTo("/vulnerabilities")).withRequestBody(equalToJson(vulnerabilityJson))
                .willReturn(aJsonResponse(HttpConstants.STATUS_CREATED).withBody(vulnerabilityJson)));

        SW360Vulnerability createdVulnerability = waitFor(vulnerabilityClient.createVulnerability(vulnerability));

        assertThat(createdVulnerability).isEqualTo(vulnerability);
    }

    private void cleanUpVulnerability() {
        try {
            wireMockRule.stubFor(delete(urlPathEqualTo("/vulnerabilities/" + EXTERNAL_ID))
                    .willReturn(aJsonResponse(HttpConstants.STATUS_MULTI_STATUS)));

            waitFor(vulnerabilityClient.deleteVulnerability(EXTERNAL_ID));
        } catch (Exception exp) {
        }
    }

    private List<SW360HalResource> createVulnerabilityReleaseRelation() throws IOException {

        SW360ReleaseVulnerabilityRelation releaseVulnerabilityRelation = readTestJsonFile(
                resolveTestFileURL("release_vulnerability_relation.json"), SW360ReleaseVulnerabilityRelation.class);
        
        SW360Release release = null;
        List<SW360HalResource> compReleaseList = new ArrayList<>();
        if (RUN_REST_INTEGRATION_TEST) {
            SW360Component component = SW360ReleaseClientIT.componentFromJsonForIntegrationTest();
            component.setName("TestProject1");
            SW360Component createdComponent = waitFor(componentClient.createComponent(component));
            SW360Release sw360Release = new SW360Release();
            sw360Release.setComponentId(createdComponent.getId());
            sw360Release.setVersion("1.1");
            release = waitFor(releaseClient.createRelease(sw360Release));
            assertNotNull(release);
            releaseVulnerabilityRelation.setReleaseId(release.getId());
            compReleaseList.add(createdComponent);
            compReleaseList.add(release);
        }
        String releaseVulnerabilityRelationJson = toJson(releaseVulnerabilityRelation);
        wireMockRule.stubFor(post(urlEqualTo("/vulnerabilities/" + EXTERNAL_ID + "/releaseVulnerabilityRelation"))
                .withRequestBody(equalToJson(releaseVulnerabilityRelationJson))
                .willReturn(aJsonResponse(HttpConstants.STATUS_CREATED).withBody(releaseVulnerabilityRelationJson)));

        SW360ReleaseVulnerabilityRelation createdReleaseVulnerabilityRelation = waitFor(
                vulnerabilityClient.createVulnerabilityReleaseRelation(EXTERNAL_ID, releaseVulnerabilityRelation));
        releaseVulnerabilityRelation.setVulnerabilityId(createdReleaseVulnerabilityRelation.vulnerabilityId);
        assertTrue(createdReleaseVulnerabilityRelation.equals(releaseVulnerabilityRelation));
        return compReleaseList;
    }

    private void cleanUpVulnerabilityReleaseRealtion() {
        try {
            wireMockRule.stubFor(delete(urlPathEqualTo("/vulnerabilities/" + EXTERNAL_ID + "/release/1234"))
                    .willReturn(aJsonResponse(HttpConstants.STATUS_MULTI_STATUS)));

            waitFor(vulnerabilityClient.deleteVulnerabilityReleaseRelation(EXTERNAL_ID, "1234"));
        } catch (Exception exp) {

        }
    }

    @After
    public void cleanUp() {
        cleanUpVulnerabilityReleaseRealtion();
        cleanUpVulnerability();
    }
}
