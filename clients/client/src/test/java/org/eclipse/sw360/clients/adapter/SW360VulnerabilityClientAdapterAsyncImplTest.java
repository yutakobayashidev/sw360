/*
 * Copyright Siemens AG, 2021. Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.clients.adapter;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.fail;
import static org.eclipse.sw360.clients.utils.FutureUtils.block;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.*;
import java.util.concurrent.CompletableFuture;

import org.eclipse.sw360.clients.rest.SW360VulnerabilityClient;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360CVEReference;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360ReleaseVulnerabilityRelation;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360VendorAdvisory;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360VerificationState;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360VerificationStateInfo;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360Vulnerability;
import org.eclipse.sw360.clients.utils.SW360ClientException;
import org.eclipse.sw360.clients.rest.MultiStatusResponse;
import org.eclipse.sw360.http.utils.HttpConstants;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

public class SW360VulnerabilityClientAdapterAsyncImplTest {
    private static final String EXTERNAL_ID = "12345";

    private SW360VulnerabilityClientAdapterAsync vulnerabilityClientAdapter;
    private SW360VulnerabilityClient vulnerabilityClient;
    private SW360Vulnerability vulnerability;

    @Before
    public void setUp() {
        vulnerabilityClient = mock(SW360VulnerabilityClient.class);
        vulnerability = mkSW360Vulnerability(EXTERNAL_ID);
        vulnerabilityClientAdapter = new SW360VulnerabilityClientAdapterAsyncImpl(vulnerabilityClient);
    }

    @Test
    public void testCreateVulnerability() {
        when(vulnerabilityClient.createVulnerability(vulnerability))
                .thenReturn(CompletableFuture.completedFuture(vulnerability));

        SW360Vulnerability createdVulnerability = block(vulnerabilityClientAdapter.createVulnerability(vulnerability));

        assertThat(createdVulnerability).isEqualTo(vulnerability);
        verify(vulnerabilityClient).createVulnerability(vulnerability);
    }

    @Test
    public void testCreateVulnerabilityInvalid() {
        vulnerability.setExternalId("");

        try {
            block(vulnerabilityClientAdapter.createVulnerability(vulnerability));
            fail("Invalid release not detected");
        } catch (SW360ClientException e) {
            assertThat(e.getMessage()).contains("Cannot create vulnerability with external Id - ",
                    vulnerability.getExternalId());
            assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class);
        }
    }

    @Test
    public void testUpdateVulnerability() {
        when(vulnerabilityClient.patchVulnerability(vulnerability, vulnerability.getExternalId()))
                .thenReturn(CompletableFuture.completedFuture(vulnerability));

        SW360Vulnerability updatedVulnerability = block(
                vulnerabilityClientAdapter.updateVulnerability(vulnerability, vulnerability.getExternalId()));

        assertThat(updatedVulnerability).isEqualTo(vulnerability);
        verify(vulnerabilityClient).patchVulnerability(vulnerability, vulnerability.getExternalId());
    }

    @Test
    public void testGetVulnerabilityByExternalId() {
        when(vulnerabilityClient.getVulnerabilityByExternalId(vulnerability.getExternalId()))
                .thenReturn(CompletableFuture.completedFuture(vulnerability));

        Optional<SW360Vulnerability> sw360VulnerabilityOpt = block(
                vulnerabilityClientAdapter.getVulnerabilityByExternalId(vulnerability.getExternalId()));

        assertThat(sw360VulnerabilityOpt.get()).isEqualTo(vulnerability);
        verify(vulnerabilityClient).getVulnerabilityByExternalId(vulnerability.getExternalId());
    }

    @Test
    public void testGetVulnerabilities() {
        SW360Vulnerability vulnerability2 = mkSW360Vulnerability("4321");
        vulnerability2.setDescription("Test Description");

        List<SW360Vulnerability> vulnerabilityList = new ArrayList<SW360Vulnerability>();
        vulnerabilityList.add(vulnerability);
        vulnerabilityList.add(vulnerability2);
        when(vulnerabilityClient.getVulnerabilities()).thenReturn(CompletableFuture.completedFuture(vulnerabilityList));

        List<SW360Vulnerability> sw360VulnerabilityList = block(vulnerabilityClientAdapter.getVulnerabilities());

        assertThat(sw360VulnerabilityList.get(0)).isEqualTo(vulnerability);
        assertThat(sw360VulnerabilityList.get(1)).isEqualTo(vulnerability2);
        verify(vulnerabilityClient).getVulnerabilities();
    }

    @Test
    public void testDeleteVulnerability() {
        Map<String, Integer> responses = new HashMap<String, Integer>();
        responses.put(EXTERNAL_ID, 200);
        MultiStatusResponse response = new MultiStatusResponse(Collections.singletonMap(EXTERNAL_ID, HttpConstants.STATUS_OK));
        when(vulnerabilityClient.deleteVulnerability(Mockito.any()))
                .thenReturn(CompletableFuture.completedFuture(response));

        MultiStatusResponse multiStatusResponse = block(vulnerabilityClientAdapter.deleteVulnerability(vulnerability.getExternalId()));

        assertThat(multiStatusResponse.getStatus(EXTERNAL_ID)).isEqualTo(200);
        verify(vulnerabilityClient).deleteVulnerability(vulnerability.getExternalId());
    }

    @Test
    public void testCreateReleaseVulnerabilityRelation() {
        SW360ReleaseVulnerabilityRelation releaseVulnerabilityRelation = mkSW360ReleaseVulnerabilityRelation("1234");
        when(vulnerabilityClient.createVulnerabilityReleaseRelation(EXTERNAL_ID, releaseVulnerabilityRelation))
                .thenReturn(CompletableFuture.completedFuture(releaseVulnerabilityRelation));

        SW360ReleaseVulnerabilityRelation createdReleaseVulnerabilityRelation = block(vulnerabilityClientAdapter
                .createVulnerabilityReleaseRelation(EXTERNAL_ID, releaseVulnerabilityRelation));

        assertThat(createdReleaseVulnerabilityRelation).isEqualTo(releaseVulnerabilityRelation);
        verify(vulnerabilityClient).createVulnerabilityReleaseRelation(EXTERNAL_ID, releaseVulnerabilityRelation);
    }

    @Test
    public void testDeleteReleaseVulnerabilityRelation() {
        Map<String, Integer> responses = new HashMap<String, Integer>();
        responses.put(EXTERNAL_ID + " - 1234", 200);
        MultiStatusResponse response = new MultiStatusResponse(Collections.singletonMap(EXTERNAL_ID + " - 1234", HttpConstants.STATUS_OK));
        when(vulnerabilityClient.deleteVulnerabilityReleaseRelation(EXTERNAL_ID, "1234"))
                .thenReturn(CompletableFuture.completedFuture(response));

        MultiStatusResponse multiStatusResponse = block(
                vulnerabilityClientAdapter.deleteVulnerabilityReleaseRelation(EXTERNAL_ID, "1234"));

        assertThat(multiStatusResponse.getStatus(EXTERNAL_ID + " - 1234")).isEqualTo(200);
        verify(vulnerabilityClient).deleteVulnerabilityReleaseRelation(EXTERNAL_ID, "1234");
    }

    private static SW360Vulnerability mkSW360Vulnerability(String externalId) {
        SW360CVEReference cveref = new SW360CVEReference().setNumber("123").setYear("2021");
        Set<SW360CVEReference> cveRefList = new HashSet<SW360CVEReference>();
        cveRefList.add(cveref);
        SW360VendorAdvisory va = new SW360VendorAdvisory().setVendor("vendor").setName("name")
                .setUrl("http://test.com");
        Set<SW360VendorAdvisory> vaList = new HashSet<SW360VendorAdvisory>();
        vaList.add(va);
        SW360Vulnerability vulnerability = new SW360Vulnerability().setExternalId(externalId)
                .setCveReferences(cveRefList).setVendorAdvisories(vaList);

        return vulnerability;
    }

    private static SW360ReleaseVulnerabilityRelation mkSW360ReleaseVulnerabilityRelation(String releaseId) {
        SW360VerificationStateInfo vsi = new SW360VerificationStateInfo().setCheckedOn("2021-06-21")
                .setCheckedBy("admin@sw360.org").setVerificationState(SW360VerificationState.CHECKED);

        List<SW360VerificationStateInfo> vsiList = new ArrayList<SW360VerificationStateInfo>();
        vsiList.add(vsi);
        SW360ReleaseVulnerabilityRelation releaseVulnerabilityRelation = new SW360ReleaseVulnerabilityRelation()
                .setReleaseId(releaseId).setVerificationStateInfo(vsiList);

        return releaseVulnerabilityRelation;
    }

}
