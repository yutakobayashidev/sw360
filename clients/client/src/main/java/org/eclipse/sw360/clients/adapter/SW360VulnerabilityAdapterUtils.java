/*
 * Copyright Siemens AG, 2021. Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.clients.adapter;

import org.apache.commons.lang3.StringUtils;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360CVEReference;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360ReleaseVulnerabilityRelation;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360VendorAdvisory;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360VerificationStateInfo;
import org.eclipse.sw360.clients.rest.resource.vulnerabilities.SW360Vulnerability;

import java.util.HashSet;
import java.util.Set;

class SW360VulnerabilityAdapterUtils {

    private SW360VulnerabilityAdapterUtils() {
    }

    /**
     * Validates the given vulnerabilities before it is sent to the server. Checks
     * whether all mandatory properties are set. If validation failures are
     * detected, exceptions with corresponding messages are thrown.
     *
     * @param vulnerability the vulnerability to be validated
     * @return the validated vulnerability
     * @throws IllegalArgumentException if the vulnerability is not valid
     */
    public static SW360Vulnerability validateVulnerability(SW360Vulnerability vulnerability) {
        if (StringUtils.isBlank(vulnerability.getExternalId())) {
            throw new IllegalArgumentException("Invalid vulnerability: missing property 'externalId'.");
        }

        if (vulnerability.getCveReferences() != null) {
            Set<SW360CVEReference> cveReferences = new HashSet<>();

            vulnerability.getCveReferences().stream().forEach(i -> {
                String[] yearAndNumber = i.split("-");
                SW360CVEReference cveRefer = new SW360CVEReference();
                if(yearAndNumber.length == 2) {
                    cveRefer.setNumber(yearAndNumber[1]).setYear(yearAndNumber[0]);
                } else {
                    cveRefer.setNumber("").setYear(yearAndNumber[0]);
                }

                cveReferences.add(cveRefer);
            });

            cveReferences.stream().forEach(SW360VulnerabilityAdapterUtils::validateCVEReference );
        }

        if (vulnerability.getVendorAdvisories() != null) {
            vulnerability.getVendorAdvisories().stream()
                    .forEach(SW360VulnerabilityAdapterUtils::validateVendorAdvisory);
        }
        return vulnerability;
    }

    /**
     * Validates the given SW360ReleaseVulnerabilityRelation before it is sent to the server. Checks
     * whether all mandatory properties are set. If validation failures are
     * detected, exceptions with corresponding messages are thrown.
     *
     * @param sw360ReleaseVulnerabilityRelation the ReleaseVulnerabilityRelation to be validated
     * @return the validated ReleaseVulnerabilityRelation
     * @throws IllegalArgumentException if the ReleaseVulnerabilityRelation is not valid
     */
    public static SW360ReleaseVulnerabilityRelation validateReleaseVulnerabilityRelation(
            SW360ReleaseVulnerabilityRelation sw360ReleaseVulnerabilityRelation) {

        if (StringUtils.isBlank(sw360ReleaseVulnerabilityRelation.getReleaseId())) {
            throw new IllegalArgumentException("Invalid ReleaseVulnerabilityRelation: missing property 'releaseId'.");
        }

        if (sw360ReleaseVulnerabilityRelation.getVerificationStateInfo() != null) {
            sw360ReleaseVulnerabilityRelation.getVerificationStateInfo().stream()
                    .forEach(SW360VulnerabilityAdapterUtils::validateVerificationStateInfo);
        }
        return sw360ReleaseVulnerabilityRelation;
    }

    /**
     * Validates the given VerificationStateInfo before it is sent to the server. Checks
     * whether all mandatory properties are set. If validation failures are
     * detected, exceptions with corresponding messages are thrown.
     *
     * @param sw360VerificationStateInfo the VerificationStateInfo to be validated
     * @return the validated VerificationStateInfo
     * @throws IllegalArgumentException if the VerificationStateInfo is not valid
     */
    private static SW360VerificationStateInfo validateVerificationStateInfo(
            SW360VerificationStateInfo sw360VerificationStateInfo) {
        if (StringUtils.isBlank(sw360VerificationStateInfo.getCheckedBy())) {
            throw new IllegalArgumentException("Invalid VerificationStateInfo: missing property 'checkedBy'.");
        }

        if (StringUtils.isBlank(sw360VerificationStateInfo.getCheckedOn())) {
            throw new IllegalArgumentException("Invalid VerificationStateInfo: missing property 'checkedOn'.");
        }

        if (sw360VerificationStateInfo.getVerificationState() == null) {
            throw new IllegalArgumentException("Invalid VerificationStateInfo: missing property 'verificationState'.");
        }

        return sw360VerificationStateInfo;
    }

    /**
     * Validates the given CVEReference before it is sent to the server. Checks
     * whether all mandatory properties are set. If validation failures are
     * detected, exceptions with corresponding messages are thrown.
     *
     * @param sw360CVEReference the CVEReference to be validated
     * @return the validated CVEReference
     * @throws IllegalArgumentException if the CVEReference is not valid
     */
    private static SW360CVEReference validateCVEReference(SW360CVEReference sw360CVEReference) {
        if (StringUtils.isBlank(sw360CVEReference.getYear())) {
            throw new IllegalArgumentException("Invalid CVEReference: missing property 'year'.");
        }
        try {
            int year = Integer.parseInt(sw360CVEReference.getYear());
            if (year <= 0) {
                throw new IllegalArgumentException("Invalid CVEReference: property 'year' should be a valid year.");
            }
        } catch (NumberFormatException nfe) {
            throw new IllegalArgumentException("Invalid CVEReference: property 'year' should be a valid year.");
        }
        if (StringUtils.isBlank(sw360CVEReference.getNumber())) {
            throw new IllegalArgumentException("Invalid CVEReference: missing property 'number'.");
        }
        try {
            Integer.parseInt(sw360CVEReference.getNumber());
        } catch (NumberFormatException nfe) {
            throw new IllegalArgumentException("Invalid CVEReference: property 'number' should be a valid number.");
        }
        return sw360CVEReference;
    }

    /**
     * Validates the given VendorAdvisory before it is sent to the server. Checks
     * whether all mandatory properties are set. If validation failures are
     * detected, exceptions with corresponding messages are thrown.
     *
     * @param sw360VendorAdvisory the VendorAdvisory to be validated
     * @return the validated VendorAdvisory
     * @throws IllegalArgumentException if the VendorAdvisory is not valid
     */
    private static SW360VendorAdvisory validateVendorAdvisory(SW360VendorAdvisory sw360VendorAdvisory) {
        if (StringUtils.isBlank(sw360VendorAdvisory.getVendor())) {
            throw new IllegalArgumentException("Invalid VendorAdvisory: missing property 'vendor'.");
        }

        if (StringUtils.isBlank(sw360VendorAdvisory.getName())) {
            throw new IllegalArgumentException("Invalid VendorAdvisory: missing property 'name'.");
        }

        if (StringUtils.isBlank(sw360VendorAdvisory.getUrl())) {
            throw new IllegalArgumentException("Invalid VendorAdvisory: missing property 'url'.");
        }

        return sw360VendorAdvisory;
    }
}
