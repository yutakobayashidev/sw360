/*
 * Copyright Bosch Software Innovations GmbH, 2017.
 * With modifications by Siemens AG, 2018.
 * Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.rest.resourceserver.vulnerability;

import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.net.URI;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

import javax.websocket.server.PathParam;

import org.apache.thrift.TException;
import org.eclipse.sw360.datahandler.common.CommonUtils;
import org.eclipse.sw360.datahandler.common.SW360Utils;
import org.eclipse.sw360.datahandler.permissions.DocumentPermissions;
import org.eclipse.sw360.datahandler.thrift.SW360Exception;
import org.eclipse.sw360.datahandler.thrift.components.Release;
import org.eclipse.sw360.datahandler.thrift.users.RequestedAction;
import org.eclipse.sw360.datahandler.thrift.users.User;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.ReleaseVulnerabilityRelation;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.Vulnerability;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.VulnerabilityApiDTO;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.VulnerabilityWithReleaseRelations;
import org.eclipse.sw360.rest.resourceserver.core.HalResource;
import org.eclipse.sw360.rest.resourceserver.core.RestControllerHelper;
import org.eclipse.sw360.rest.resourceserver.release.Sw360ReleaseService;
import org.eclipse.sw360.rest.resourceserver.vulnerability.Sw360VulnerabilityService.VulnerabilityOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.rest.webmvc.BasePathAwareController;
import org.springframework.data.rest.webmvc.RepositoryLinksResource;
import org.springframework.data.rest.webmvc.ResourceNotFoundException;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.server.RepresentationModelProcessor;
import org.springframework.hateoas.CollectionModel;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.util.ArrayList;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;

import static org.eclipse.sw360.datahandler.permissions.PermissionUtils.makePermission;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;

@BasePathAwareController
@Slf4j
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class VulnerabilityController implements RepresentationModelProcessor<RepositoryLinksResource> {
    static final String VULNERABILITIES_URL = "/vulnerabilities";

    @NonNull
    private final Sw360VulnerabilityService vulnerabilityService;

    @NonNull
    private final RestControllerHelper restControllerHelper;
    
    @NonNull
    private Sw360ReleaseService releaseService;

    @RequestMapping(value = VULNERABILITIES_URL)
    public ResponseEntity<CollectionModel<EntityModel<VulnerabilityApiDTO>>> getVulnerabilities() {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        List<Vulnerability> vulnerabilities = vulnerabilityService.getVulnerabilities(user);
        List<EntityModel<VulnerabilityApiDTO>> vulnerabilityApiDTOResources = new ArrayList<>();

        vulnerabilities.forEach(v -> {
            Set<Release> releaseList = getReleaseRelationsInfo(v, user);
            VulnerabilityApiDTO vulnerabilityApiDTO = new VulnerabilityApiDTO();
            restControllerHelper.setDataVulApiDTO(vulnerabilityApiDTO, v, releaseList);
            vulnerabilityApiDTOResources.add(EntityModel.of(vulnerabilityApiDTO));

        });

        CollectionModel<EntityModel<VulnerabilityApiDTO>> resources = CollectionModel.of(vulnerabilityApiDTOResources);
        return new ResponseEntity<>(resources, HttpStatus.OK);
    }

    @RequestMapping(VULNERABILITIES_URL + "/{id}")
    public ResponseEntity<HalResource<VulnerabilityApiDTO>> getVulnerability(
            @PathVariable("id") String id) {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        Vulnerability vulnerability = vulnerabilityService.getVulnerabilityByExternalId(id, user);
        Set<Release> releaseList = getReleaseRelationsInfo(vulnerability, user);
        VulnerabilityApiDTO vulnerabilityApiDTO = new VulnerabilityApiDTO();
        restControllerHelper.setDataVulApiDTO(vulnerabilityApiDTO, vulnerability, releaseList);
        HalResource<VulnerabilityApiDTO> vulnerabilityHalResource = createHalVulnerability(vulnerabilityApiDTO, user);

        return new ResponseEntity<>(vulnerabilityHalResource, HttpStatus.OK);
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @PostMapping(VULNERABILITIES_URL)
    public ResponseEntity createVulnerability(@RequestBody Map<String, Object> vulnerabilityAsMap) {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        ObjectMapper mapper = vulnerabilityService.getObjectMapper();
        VulnerabilityApiDTO vulnerabilityApiDTO = mapper.convertValue(vulnerabilityAsMap, VulnerabilityApiDTO.class);
        String externalId = vulnerabilityApiDTO.getExternalId();
        if (CommonUtils.isNullEmptyOrWhitespace(externalId)) {
            throw new HttpMessageNotReadableException("External Id should not be null or empty");
        }

        try {
            vulnerabilityService.getVulnerabilityByExternalId(externalId, user);
            throw new HttpMessageNotReadableException("Conflict Vulnerability with same external id already exists.");
        } catch (ResourceNotFoundException e) {

        }
        Vulnerability vulnerability = new Vulnerability(externalId);
        restControllerHelper.setDataForVulnerability(vulnerabilityApiDTO, vulnerability);

        vulnerabilityService.createUpdateDeleteVulnerability(vulnerability, user, VulnerabilityOperation.CREATE);

        URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(externalId)
                .toUri();

        return ResponseEntity.created(location).body(vulnerabilityAsMap);
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @PatchMapping(VULNERABILITIES_URL + "/{externalId}")
    public ResponseEntity updateVulnerability(@PathVariable String externalId,
            @RequestBody Map<String, Object> vulnerabilityAsMap) {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        ObjectMapper mapper = vulnerabilityService.getObjectMapper();
        VulnerabilityApiDTO vulnerabilityApiDTO = mapper.convertValue(vulnerabilityAsMap, VulnerabilityApiDTO.class);
        if (CommonUtils.isNullEmptyOrWhitespace(externalId)) {
            throw new HttpMessageNotReadableException("External Id should not be null or empty");
        }
        if (!externalId.equals(vulnerabilityApiDTO.getExternalId())) {
            throw new HttpMessageNotReadableException("External Id is not correct");
        }
        Vulnerability vulnerability = new Vulnerability(externalId);
        restControllerHelper.setDataForVulnerability(vulnerabilityApiDTO, vulnerability);

        Vulnerability vulnerabilityByExtId = vulnerabilityService.getVulnerabilityByExternalId(externalId, user);
        vulnerabilityService.updateFromVulnerabilityDTO(vulnerabilityByExtId, vulnerability, vulnerabilityApiDTO);
        vulnerabilityService.createUpdateDeleteVulnerability(vulnerabilityByExtId, user, VulnerabilityOperation.UPDATE);

        URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(externalId)
                .toUri();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        return ResponseEntity.created(location).body(mapper.convertValue(vulnerabilityAsMap, Map.class));
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @DeleteMapping(VULNERABILITIES_URL + "/{externalId}")
    public ResponseEntity deleteVulnerability(@PathVariable String externalId) {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        if (CommonUtils.isNullEmptyOrWhitespace(externalId)) {
            throw new HttpMessageNotReadableException("External Id should not be null or empty");
        }
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = vulnerabilityService
                .getVulnerabilityWithReleaseRelations(externalId, user);

        if (!CommonUtils.isNotEmpty(vulnerabilityWithReleaseRelations.getReleaseRelation())) {
            vulnerabilityService.createUpdateDeleteVulnerability(vulnerabilityWithReleaseRelations.getVulnerability(),
                    user, VulnerabilityOperation.DELETE);
        } else {
            List<Release> releasesInRelation = new ArrayList<>();
            Set<String> releaseIdsInRelation = vulnerabilityWithReleaseRelations.getReleaseRelation().stream()
                    .map(ReleaseVulnerabilityRelation::getReleaseId)
                    .collect(Collectors.toSet());

            releaseIdsInRelation.stream().forEach(releaseId -> {
                try {
                    Release release = releaseService.getReleaseForUserById(releaseId, user);
                    if (release != null) {
                        releasesInRelation.add(release);
                    }
                } catch (TException | ResourceNotFoundException e) {
                    log.error("Error when get release: " + releaseId + ". " + e.getMessage());
                }
            });

            if (releasesInRelation.size() == 0) {
                vulnerabilityService.createUpdateDeleteVulnerability(vulnerabilityWithReleaseRelations.getVulnerability(),
                        user, VulnerabilityOperation.DELETE);
            } else {
                String releaseIds = releasesInRelation.stream().filter(Objects::nonNull)
                        .map(Release::getId).filter(CommonUtils::isNotNullEmptyOrWhitespace)
                        .collect(Collectors.joining(", "));
                throw new AccessDeniedException("Vulnerability used/linked to releases : " + releaseIds);
            }
        }
        return ResponseEntity.ok().build();
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @PostMapping(value = VULNERABILITIES_URL + "/{externalId}/releaseVulnerabilityRelation")
    public ResponseEntity postVulnearbilitytoReleases(@PathVariable String externalId,
            @RequestBody ReleaseVulnerabilityRelation releaseVulnerabilityRelation) throws TException {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        String releaseId = releaseVulnerabilityRelation.getReleaseId();
        if (CommonUtils.isNullEmptyOrWhitespace(externalId) || CommonUtils.isNullEmptyOrWhitespace(releaseId)) {
            throw new HttpMessageNotReadableException("External Id or Release Id should not be null or empty");
        }
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = vulnerabilityService
                .getVulnerabilityWithReleaseRelations(externalId, user);

        Release releaseForUserById = releaseService.getReleaseForUserById(releaseId, user);
        DocumentPermissions<Release> permissions = makePermission(releaseForUserById, user);
        if (!permissions.isActionAllowed(RequestedAction.WRITE)) {
            throw new AccessDeniedException("User doesnot have write access to release : " + releaseId);
        }

        long count = 0;
        if (CommonUtils.isNotEmpty(vulnerabilityWithReleaseRelations.getReleaseRelation())) {
            count = vulnerabilityWithReleaseRelations.getReleaseRelation().stream().filter(Objects::nonNull)
                    .map(ReleaseVulnerabilityRelation::getReleaseId).filter(CommonUtils::isNotNullEmptyOrWhitespace)
                    .filter(relationReleaseId -> relationReleaseId.equals(releaseId)).count();
        }
        if (count == 0) {
            releaseVulnerabilityRelation
                    .setVulnerabilityId(vulnerabilityWithReleaseRelations.getVulnerability().getId());
            vulnerabilityService.createUpdateDeleteVulnerabilityReleaseRelation(releaseVulnerabilityRelation, user,
                    VulnerabilityOperation.CREATE);
        } else {
            throw new HttpMessageNotReadableException("Vulnerability Release Relation already exists");
        }
        return ResponseEntity.ok().body(releaseVulnerabilityRelation);
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @DeleteMapping(value = VULNERABILITIES_URL + "/{externalId}/release/{releaseId}")
    public ResponseEntity deleteVulnearbilitytoReleasesRealtion(@PathVariable(value = "externalId") String externalId,
            @PathVariable(value = "releaseId") String releaseId) throws TException {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        if (CommonUtils.isNullEmptyOrWhitespace(externalId) || CommonUtils.isNullEmptyOrWhitespace(releaseId)) {
            throw new HttpMessageNotReadableException("External Id or Release Id should not be null or empty");
        }

        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = vulnerabilityService
                .getVulnerabilityWithReleaseRelations(externalId, user);

        Release releaseForUserById = releaseService.getReleaseForUserById(releaseId, user);
        DocumentPermissions<Release> permissions = makePermission(releaseForUserById, user);

        if (!permissions.isActionAllowed(RequestedAction.WRITE)) {
            throw new AccessDeniedException("User doesnot have write access to release : " + releaseId);
        }

        Optional<ReleaseVulnerabilityRelation> releaseVulnerabilityRelationOpt = null;
        if (CommonUtils.isNotEmpty(vulnerabilityWithReleaseRelations.getReleaseRelation())) {
            releaseVulnerabilityRelationOpt = vulnerabilityWithReleaseRelations.getReleaseRelation().stream()
                    .filter(Objects::nonNull).filter(vulRelRelation -> releaseId.equals(vulRelRelation.getReleaseId()))
                    .findFirst();
        }

        if (releaseVulnerabilityRelationOpt != null && releaseVulnerabilityRelationOpt.isPresent()) {
            vulnerabilityService.createUpdateDeleteVulnerabilityReleaseRelation(releaseVulnerabilityRelationOpt.get(),
                    user, VulnerabilityOperation.DELETE);
        } else {
            throw new HttpMessageNotReadableException("Vulnerability Release Relation doesnot exists");
        }
        return ResponseEntity.ok().build();
    }

    @Override
    public RepositoryLinksResource process(RepositoryLinksResource resource) {
        resource.add(linkTo(VulnerabilityController.class).slash("api" + VULNERABILITIES_URL).withRel("vulnerabilities"));
        return resource;
    }

    private HalResource<VulnerabilityApiDTO> createHalVulnerability(VulnerabilityApiDTO vulnerabilityApiDTO, User user) {
        return new HalResource<>(vulnerabilityApiDTO);
    }

    private Set<Release> getReleaseRelationsInfo(Vulnerability vulnerability, User user) {
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = vulnerabilityService
                .getVulnerabilityWithReleaseRelations(vulnerability.getExternalId(), user);
        Set<Release> releaseList = new HashSet<Release>();
        if(vulnerabilityWithReleaseRelations == null) {
            return releaseList;
        }

        List<ReleaseVulnerabilityRelation> releaseRelations = vulnerabilityWithReleaseRelations.getReleaseRelation();
        for (ReleaseVulnerabilityRelation releaseRelation :releaseRelations) {
            String releaseId = releaseRelation.getReleaseId();
            try {
                Release releaseForUserById = releaseService.getReleaseForUserById(releaseId, user);
                releaseList.add(releaseForUserById);
            } catch (TException |ResourceNotFoundException e) {
                log.error("Error when get release " + releaseId + " " + e.getMessage());
            }
        }

        return releaseList;
    }
}
