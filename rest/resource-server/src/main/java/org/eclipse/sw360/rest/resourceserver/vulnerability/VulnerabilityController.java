/*
 * Copyright Bosch Software Innovations GmbH, 2017.
 * With modifications by Siemens AG, 2018.
 * Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.rest.resourceserver.vulnerability;

import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.net.URI;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

import javax.websocket.server.PathParam;

import org.apache.thrift.TException;
import org.eclipse.sw360.datahandler.common.CommonUtils;
import org.eclipse.sw360.datahandler.common.SW360Utils;
import org.eclipse.sw360.datahandler.permissions.DocumentPermissions;
import org.eclipse.sw360.datahandler.thrift.RequestStatus;
import org.eclipse.sw360.datahandler.thrift.SW360Exception;
import org.eclipse.sw360.datahandler.thrift.components.Release;
import org.eclipse.sw360.datahandler.thrift.users.RequestedAction;
import org.eclipse.sw360.datahandler.thrift.users.User;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.ReleaseVulnerabilityRelation;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.Vulnerability;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.VulnerabilityWithReleaseRelations;
import org.eclipse.sw360.rest.resourceserver.core.HalResource;
import org.eclipse.sw360.rest.resourceserver.core.MultiStatus;
import org.eclipse.sw360.rest.resourceserver.core.RestControllerHelper;
import org.eclipse.sw360.rest.resourceserver.release.Sw360ReleaseService;
import org.eclipse.sw360.rest.resourceserver.vulnerability.Sw360VulnerabilityService.VulnerabilityOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.rest.webmvc.BasePathAwareController;
import org.springframework.data.rest.webmvc.RepositoryLinksResource;
import org.springframework.data.rest.webmvc.ResourceNotFoundException;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.server.RepresentationModelProcessor;
import org.springframework.hateoas.CollectionModel;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.util.ArrayList;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;

import static org.eclipse.sw360.datahandler.permissions.PermissionUtils.makePermission;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;

@BasePathAwareController
@Slf4j
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class VulnerabilityController implements RepresentationModelProcessor<RepositoryLinksResource> {
    static final String VULNERABILITIES_URL = "/vulnerabilities";

    @NonNull
    private final Sw360VulnerabilityService vulnerabilityService;

    @NonNull
    private final RestControllerHelper restControllerHelper;
    
    @NonNull
    private Sw360ReleaseService releaseService;

    @RequestMapping(value = VULNERABILITIES_URL)
    public ResponseEntity<CollectionModel<EntityModel<Vulnerability>>> getVulnerabilities() {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        List<Vulnerability> vulnerabilities = vulnerabilityService.getVulnerabilities(user);
        List<EntityModel<Vulnerability>> vulnerabilityResources = new ArrayList<>();

        vulnerabilities.forEach(v -> {
            Vulnerability embeddedVulnerability = restControllerHelper.convertToEmbeddedVulnerability(v);
            vulnerabilityResources.add(EntityModel.of(embeddedVulnerability));

        });

        CollectionModel<EntityModel<Vulnerability>> resources = CollectionModel.of(vulnerabilityResources);
        return new ResponseEntity<>(resources, HttpStatus.OK);
    }

    @RequestMapping(VULNERABILITIES_URL + "/{id}")
    public ResponseEntity<HalResource<Vulnerability>> getVulnerability(
            @PathVariable("id") String id) {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        Vulnerability vulnerability = vulnerabilityService.getVulnerabilityByExternalId(id, user);
        HalResource<Vulnerability> vulnerabilityHalResource = createHalVulnerability(vulnerability, user);
        return new ResponseEntity<>(vulnerabilityHalResource, HttpStatus.OK);
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @PostMapping(VULNERABILITIES_URL)
    public ResponseEntity createVulnerability(@RequestBody Map<String, Object> vulnerabilityAsMap) {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        ObjectMapper mapper = vulnerabilityService.getObjectMapper();
        Vulnerability vulnerability = mapper.convertValue(vulnerabilityAsMap, Vulnerability.class);
        String externalId = vulnerability.getExternalId();
        if (CommonUtils.isNullEmptyOrWhitespace(externalId)) {
            throw new HttpMessageNotReadableException("External Id should not be null or empty");
        }

        try {
            vulnerabilityService.getVulnerabilityByExternalId(externalId, user);
            throw new HttpMessageNotReadableException("Conflict Vulnerability with same external id already exists.");
        } catch (ResourceNotFoundException e) {

        }

        vulnerability.setLastUpdateDate(SW360Utils.getCreatedOn());
        vulnerabilityService.createUpdateDeleteVulnerability(vulnerability, user, VulnerabilityOperation.CREATE);

        URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(externalId)
                .toUri();

        return ResponseEntity.created(location).body(vulnerabilityAsMap);
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @PatchMapping(VULNERABILITIES_URL + "/{externalId}")
    public ResponseEntity updateVulnerability(@PathVariable String externalId,
            @RequestBody Map<String, Object> vulnerabilityAsMap) {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        ObjectMapper mapper = vulnerabilityService.getObjectMapper();
        Vulnerability vulnerability = mapper.convertValue(vulnerabilityAsMap, Vulnerability.class);
        vulnerability.setExternalId(externalId);
        if (CommonUtils.isNullEmptyOrWhitespace(externalId)) {
            throw new HttpMessageNotReadableException("External Id should not be null or empty");
        }
        Vulnerability vulnerabilityByExtId = vulnerabilityService.getVulnerabilityByExternalId(externalId, user);
        vulnerabilityService.updateFromVulnerability(vulnerabilityByExtId, vulnerability);
        vulnerabilityService.createUpdateDeleteVulnerability(vulnerabilityByExtId, user, VulnerabilityOperation.UPDATE);

        URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(externalId)
                .toUri();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        return ResponseEntity.created(location).body(mapper.convertValue(vulnerabilityByExtId, Map.class));
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @DeleteMapping(VULNERABILITIES_URL + "/{externalId}")
    public ResponseEntity deleteVulnerability(@PathVariable String externalId) {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        List<MultiStatus> results = new ArrayList<>();
        if (CommonUtils.isNullEmptyOrWhitespace(externalId)) {
            results.add(new MultiStatus(externalId, HttpStatus.BAD_REQUEST));
            log.error("External Id should not be null or empty");
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        }

        try {
            VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = vulnerabilityService.getVulnerabilityWithReleaseRelations(externalId, user);
            if (!CommonUtils.isNotEmpty(vulnerabilityWithReleaseRelations.getReleaseRelation())) {
                vulnerabilityService.createUpdateDeleteVulnerability(vulnerabilityWithReleaseRelations.getVulnerability(),
                        user, VulnerabilityOperation.DELETE);
            } else {
                String releaseIds = vulnerabilityWithReleaseRelations.getReleaseRelation().stream().filter(Objects::nonNull)
                        .map(ReleaseVulnerabilityRelation::getReleaseId).filter(CommonUtils::isNotNullEmptyOrWhitespace)
                        .collect(Collectors.joining(", "));
                log.error("Vulnerability used/linked to releases : " + releaseIds);
                results.add(new MultiStatus(externalId, HttpStatus.FORBIDDEN));
                return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
            }
        } catch (ResourceNotFoundException notFoundException) {
            results.add(new MultiStatus(externalId, HttpStatus.NOT_FOUND));
            log.error(notFoundException.getMessage());
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        } catch (AccessDeniedException accessDeniedException) {
            results.add(new MultiStatus(externalId, HttpStatus.FORBIDDEN));
            log.error(accessDeniedException.getMessage());
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        } catch (RuntimeException runtimeException) {
            results.add(new MultiStatus(externalId, HttpStatus.INTERNAL_SERVER_ERROR));
            log.error(runtimeException.getMessage());
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        }

        results.add(new MultiStatus(externalId, HttpStatus.OK));
        return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @PostMapping(value = VULNERABILITIES_URL + "/{externalId}/releaseVulnerabilityRelation")
    public ResponseEntity postVulnearbilitytoReleases(@PathVariable String externalId,
            @RequestBody ReleaseVulnerabilityRelation releaseVulnerabilityRelation) throws TException {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        String releaseId = releaseVulnerabilityRelation.getReleaseId();
        if (CommonUtils.isNullEmptyOrWhitespace(externalId) || CommonUtils.isNullEmptyOrWhitespace(releaseId)) {
            throw new HttpMessageNotReadableException("External Id or Release Id should not be null or empty");
        }
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = vulnerabilityService
                .getVulnerabilityWithReleaseRelations(externalId, user);

        Release releaseForUserById = releaseService.getReleaseForUserById(releaseId, user);
        DocumentPermissions<Release> permissions = makePermission(releaseForUserById, user);
        if (!permissions.isActionAllowed(RequestedAction.WRITE)) {
            throw new AccessDeniedException("User doesnot have write access to release : " + releaseId);
        }

        long count = 0;
        if (CommonUtils.isNotEmpty(vulnerabilityWithReleaseRelations.getReleaseRelation())) {
            count = vulnerabilityWithReleaseRelations.getReleaseRelation().stream().filter(Objects::nonNull)
                    .map(ReleaseVulnerabilityRelation::getReleaseId).filter(CommonUtils::isNotNullEmptyOrWhitespace)
                    .filter(relationReleaseId -> relationReleaseId.equals(releaseId)).count();
        }
        if (count == 0) {
            releaseVulnerabilityRelation
                    .setVulnerabilityId(vulnerabilityWithReleaseRelations.getVulnerability().getId());
            vulnerabilityService.createUpdateDeleteVulnerabilityReleaseRelation(releaseVulnerabilityRelation, user,
                    VulnerabilityOperation.CREATE);
        } else {
            throw new HttpMessageNotReadableException("Vulnerability Release Relation already exists");
        }
        return ResponseEntity.ok().body(releaseVulnerabilityRelation);
    }

    @PreAuthorize("hasAuthority('WRITE')")
    @DeleteMapping(value = VULNERABILITIES_URL + "/{externalId}/release/{releaseId}")
    public ResponseEntity deleteVulnearbilitytoReleasesRealtion(@PathVariable(value = "externalId") String externalId,
            @PathVariable(value = "releaseId") String releaseId) throws TException {
        User user = restControllerHelper.getSw360UserFromAuthentication();
        List<MultiStatus> results = new ArrayList<>();
        String resourceId = new StringBuilder(externalId).append(" - ").append(releaseId).toString();

        if (CommonUtils.isNullEmptyOrWhitespace(externalId) || CommonUtils.isNullEmptyOrWhitespace(releaseId)) {
            results.add(new MultiStatus(resourceId, HttpStatus.BAD_REQUEST));
            log.error("External Id should not be null or empty");
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        }

        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = vulnerabilityService
                .getVulnerabilityWithReleaseRelations(externalId, user);

        Release releaseForUserById = releaseService.getReleaseForUserById(releaseId, user);
        DocumentPermissions<Release> permissions = makePermission(releaseForUserById, user);

        if (!permissions.isActionAllowed(RequestedAction.WRITE)) {
            results.add(new MultiStatus(resourceId, HttpStatus.FORBIDDEN));
            log.error("User does not have write access to release : " + releaseId);
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        }

        Optional<ReleaseVulnerabilityRelation> releaseVulnerabilityRelationOpt = null;
        if (CommonUtils.isNotEmpty(vulnerabilityWithReleaseRelations.getReleaseRelation())) {
            releaseVulnerabilityRelationOpt = vulnerabilityWithReleaseRelations.getReleaseRelation().stream()
                    .filter(Objects::nonNull).filter(vulRelRelation -> releaseId.equals(vulRelRelation.getReleaseId()))
                    .findFirst();
        }

        if (releaseVulnerabilityRelationOpt == null || releaseVulnerabilityRelationOpt.isEmpty()) {
            results.add(new MultiStatus(resourceId, HttpStatus.NOT_FOUND));
            log.error("Vulnerability Release Relation doesnot exists");
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        }

        try {
            vulnerabilityService.createUpdateDeleteVulnerabilityReleaseRelation(releaseVulnerabilityRelationOpt.get(),
                    user, VulnerabilityOperation.DELETE);
            results.add(new MultiStatus(resourceId, HttpStatus.OK));
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        } catch (HttpMessageNotReadableException httpMessageNotReadableException) {
            results.add(new MultiStatus(resourceId, HttpStatus.BAD_REQUEST));
            log.error(httpMessageNotReadableException.getMessage());
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        } catch (AccessDeniedException accessDeniedException) {
            results.add(new MultiStatus(resourceId, HttpStatus.FORBIDDEN));
            log.error("User does not have write access to release : " + releaseId);
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        } catch (RuntimeException runtimeException) {
            results.add(new MultiStatus(resourceId, HttpStatus.INTERNAL_SERVER_ERROR));
            log.error(runtimeException.getMessage());
            return new ResponseEntity<>(results, HttpStatus.MULTI_STATUS);
        }
    }

    @Override
    public RepositoryLinksResource process(RepositoryLinksResource resource) {
        resource.add(linkTo(VulnerabilityController.class).slash("api" + VULNERABILITIES_URL).withRel("vulnerabilities"));
        return resource;
    }

    private HalResource<Vulnerability> createHalVulnerability(Vulnerability vulnerability, User user) {
        return new HalResource<>(vulnerability);
    }
}
