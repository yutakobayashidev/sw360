/*
 * Copyright Siemens AG, 2018. Part of the SW360 Portal Project.
 *
  * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */

package org.eclipse.sw360.rest.resourceserver.restdocs;

import org.apache.thrift.TException;
import org.eclipse.sw360.datahandler.thrift.VerificationState;
import org.eclipse.sw360.datahandler.thrift.VerificationStateInfo;
import org.eclipse.sw360.datahandler.thrift.components.Release;
import org.eclipse.sw360.datahandler.thrift.users.User;
import org.eclipse.sw360.datahandler.thrift.users.UserGroup;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.CVEReference;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.ReleaseVulnerabilityRelation;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.VendorAdvisory;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.Vulnerability;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.VulnerabilityWithReleaseRelations;
import org.eclipse.sw360.rest.resourceserver.TestHelper;
import org.eclipse.sw360.rest.resourceserver.core.JacksonCustomizations.Sw360Module.CVEReferenceMixin;
import org.eclipse.sw360.rest.resourceserver.core.JacksonCustomizations.Sw360Module.VendorAdvisoryMixin;
import org.eclipse.sw360.rest.resourceserver.core.JacksonCustomizations.Sw360Module.VulnerabilityMixinForCreateUpdate;
import org.eclipse.sw360.rest.resourceserver.release.Sw360ReleaseService;
import org.eclipse.sw360.rest.resourceserver.user.Sw360UserService;
import org.eclipse.sw360.rest.resourceserver.vulnerability.Sw360VulnerabilityService;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.data.rest.webmvc.ResourceNotFoundException;
import org.springframework.hateoas.MediaTypes;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.BDDMockito.given;
import static org.springframework.restdocs.hypermedia.HypermediaDocumentation.linkWithRel;
import static org.springframework.restdocs.hypermedia.HypermediaDocumentation.links;
import static org.springframework.restdocs.payload.PayloadDocumentation.fieldWithPath;
import static org.springframework.restdocs.payload.PayloadDocumentation.subsectionWithPath;
import static org.springframework.restdocs.payload.PayloadDocumentation.requestFields;
import static org.springframework.restdocs.payload.PayloadDocumentation.responseFields;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.patch;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@RunWith(SpringJUnit4ClassRunner.class)
public class VulnerabilitySpecTest extends TestRestDocsSpecBase {

    @Value("${sw360.test-user-id}")
    private String testUserId;

    @Value("${sw360.test-user-password}")
    private String testUserPassword;

    @MockBean
    private Sw360VulnerabilityService vulnerabilityServiceMock;

    @MockBean
    private Sw360ReleaseService releaseServiceMock;

    @MockBean
    private Sw360UserService userServiceMock;

    private Vulnerability vulnerability, vulnerability3, vulnerability4, vulnerability5;

    private ObjectMapper mapper;

    private ReleaseVulnerabilityRelation releaseVulnerabilityRelation;

    @Before
    public void before() throws TException {
        vulnerability = new Vulnerability();
        vulnerability.setId("12345");
        vulnerability.setAction("new");
        vulnerability.setCwe("common weakness enumeration");
        vulnerability.setDescription("Description of vulnerability");
        vulnerability.setExternalId("123");
        vulnerability.setPriority("high");
        vulnerability.setTitle("Title of vulnerability 12345");
        vulnerability.setRevision("1");
        vulnerability.setCvss(3);
        vulnerability.setReferences(new HashSet<>(Arrays.asList("reference-1", "reference-2")));
        vulnerability.setPublishDate("01-01-2018");
        vulnerability.setLastExternalUpdate("last-update-id-123");

        Vulnerability vulnerability2 = new Vulnerability();
        vulnerability2.setId("7854");
        vulnerability2.setAction("remove");
        vulnerability2.setCwe("common weakness enumeration");
        vulnerability2.setDescription("Description of vulnerability");
        vulnerability2.setExternalId("7543");
        vulnerability2.setPriority("low");
        vulnerability2.setTitle("Title of vulnerability 7854");
        vulnerability2.setRevision("2");
        vulnerability2.setCvss(4);

        mapper = new ObjectMapper();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.addMixIn(Vulnerability.class, VulnerabilityMixinForCreateUpdate.class);
        mapper.addMixIn(CVEReference.class, CVEReferenceMixin.class);
        mapper.addMixIn(VendorAdvisory.class, VendorAdvisoryMixin.class);

        Map<String, String> mapForImpactAccess = new HashMap<>();
        mapForImpactAccess.put("Key 1", "Value 1");
        mapForImpactAccess.put("Key 2", "Value 2");

        CVEReference cr1 = new CVEReference().setNumber("1234").setYear("1992");
        CVEReference cr2 = new CVEReference().setNumber("4321").setYear("2021");
        Set<CVEReference> cveReferenceSet = new HashSet<>();
        cveReferenceSet.add(cr1);
        cveReferenceSet.add(cr2);

        Set<VendorAdvisory> vendorAdvisorySet = new HashSet<>();
        VendorAdvisory va1 = new VendorAdvisory("vendor1", "name1", "http://url1");
        VendorAdvisory va2 = new VendorAdvisory("vendor2", "name2", "http://url2");
        vendorAdvisorySet.add(va1);
        vendorAdvisorySet.add(va2);

        Map<String, Map<String, String>> mapForCVEMetaData = new HashMap<>();
        mapForCVEMetaData.put("Cve meta data", mapForImpactAccess);

        vulnerability3 = vulnerability.deepCopy();
        vulnerability3.setAssignedExtComponentIds(new HashSet<>(Arrays.asList("comp-id-1", "comp-id-2")));
        vulnerability3.setCveReferences(cveReferenceSet);
        vulnerability3.setCveFurtherMetaDataPerSource(mapForCVEMetaData);
        vulnerability3.setImpact(mapForImpactAccess);
        vulnerability3.setAccess(mapForImpactAccess);
        vulnerability3.setCvssTime("2019-01-01");
        vulnerability3.setPriorityText("Priority Text");
        vulnerability3.setLegalNotice("Legal Notice");
        vulnerability3.setVendorAdvisories(vendorAdvisorySet);
        vulnerability3.setExtendedDescription("Extended Description");
        vulnerability3.setVulnerableConfiguration(mapForImpactAccess);
        vulnerability3.setExternalId("987");

        List<Vulnerability> vulnerabilityList = new ArrayList<>();
        vulnerabilityList.add(vulnerability);
        vulnerabilityList.add(vulnerability2);

        vulnerability4 = vulnerability3.deepCopy();
        vulnerability5 = vulnerability3.deepCopy();
        vulnerability4.setExternalId("9876567890");
        vulnerability4.setTitle("Updated Title");
        vulnerability4.setExternalId("98765");

        List<ReleaseVulnerabilityRelation> releaseRelation = new ArrayList<ReleaseVulnerabilityRelation>();
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations = new VulnerabilityWithReleaseRelations(
                vulnerability, releaseRelation);

        Release release = new Release("Test Release", "1", "12345").setId("1234");
        VerificationStateInfo vsi = new VerificationStateInfo("2021-06-17", "admin@sw360.org",
                VerificationState.CHECKED).setComment("Comment statement");
        List<VerificationStateInfo> vsiList = new ArrayList<VerificationStateInfo>();
        vsiList.add(vsi);
        releaseVulnerabilityRelation = new ReleaseVulnerabilityRelation("1234", null).setMatchedBy("matchedBy")
                .setUsedNeedle("usedNeedle").setVerificationStateInfo(vsiList);

        List<ReleaseVulnerabilityRelation> releaseVulnerabilityRelationList = new ArrayList<ReleaseVulnerabilityRelation>();
        releaseVulnerabilityRelationList.add(releaseVulnerabilityRelation);
        VulnerabilityWithReleaseRelations vulnerabilityWithReleaseRelations2 = new VulnerabilityWithReleaseRelations(
                vulnerability4, releaseVulnerabilityRelationList);

        User user = new User();
        user.setId("123456789");
        user.setEmail("admin@sw360.org");
        user.setFullname("John Doe");
        user.setUserGroup(UserGroup.ADMIN);

        given(this.userServiceMock.getUserByEmailOrExternalId("admin@sw360.org")).willReturn(user);
        given(this.releaseServiceMock.getReleaseForUserById(any(), any())).willReturn(release);
        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq(vulnerability4.getExternalId()), any())).willReturn(vulnerabilityWithReleaseRelations2);
        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq(vulnerability5.getExternalId()), any())).willReturn(vulnerabilityWithReleaseRelations);
        given(this.vulnerabilityServiceMock.getVulnerabilities(any())).willReturn(vulnerabilityList);
        given(this.vulnerabilityServiceMock.getVulnerabilityByExternalId(eq(vulnerability.getExternalId()), any())).willReturn(vulnerability);
        given(this.vulnerabilityServiceMock.getVulnerabilityByExternalId(eq(vulnerability4.getExternalId()), any())).willReturn(vulnerability4);
        given(this.vulnerabilityServiceMock.getVulnerabilityByExternalId(eq(vulnerability5.getExternalId()), any())).willReturn(vulnerability5);
        given(this.vulnerabilityServiceMock.getVulnerabilityWithReleaseRelations(eq(vulnerability.getExternalId()), any())).willReturn(vulnerabilityWithReleaseRelations);
        given(this.vulnerabilityServiceMock.getObjectMapper()).willReturn(mapper);
        Mockito.doNothing().when(vulnerabilityServiceMock).createUpdateDeleteVulnerability(any(), any(), any());
        Mockito.doNothing().when(vulnerabilityServiceMock).createUpdateDeleteVulnerabilityReleaseRelation(any(), any(), any());
        given(this.vulnerabilityServiceMock.getVulnerabilityByExternalId(eq(vulnerability3.getExternalId()), any())).willThrow(new ResourceNotFoundException("Vulnerability Not found"));
    }

    @Test
    public void should_document_get_vulnerabilities() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(get("/api/vulnerabilities")
                .header("Authorization", "Bearer " + accessToken)
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isOk())
                .andDo(this.documentationHandler.document(
                        links(
                                linkWithRel("curies").description("Curies are used for online documentation")
                        ),
                        responseFields(
                                subsectionWithPath("_embedded.sw360:vulnerabilities.[]title").description("The title of the vulnerability"),
                                subsectionWithPath("_embedded.sw360:vulnerabilities.[]externalId").description("The external Id of the vulnerability"),
                                subsectionWithPath("_embedded.sw360:vulnerabilities").description("An array of <<resources-vulnerabilities, Vulnerabilities resources>>"),
                                subsectionWithPath("_links").description("<<resources-index-links,Links>> to other resources")
                        )));
    }

    @Test
    public void should_document_get_vulnerability() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(get("/api/vulnerabilities/" + vulnerability.getExternalId())
                .header("Authorization", "Bearer " + accessToken)
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isOk())
                .andDo(this.documentationHandler.document(
                        links(
                                linkWithRel("self").description("The <<resources-vulnerabilities, Vulnerabilities resource>>")
                        ),
                        responseFields(
                                fieldWithPath("title").description("The title of the vulnerability"),
                                fieldWithPath("description").description("The vulnerability description"),
                                fieldWithPath("externalId").description("The external Id"),
                                fieldWithPath("cwe").description("The CWE (Common Weakness Enumeration) value"),
                                subsectionWithPath("_links").description("<<resources-index-links,Links>> to other resources")
                        )));
    }

    @Test
    public void should_document_create_vulnerability() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(post("/api/vulnerabilities")
                .header("Authorization", "Bearer " + accessToken)
                .contentType(MediaTypes.HAL_JSON)
                .content(mapper.writeValueAsString(vulnerability3))
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isCreated())
                .andDo(this.documentationHandler.document(
                        requestFields(
                                fieldWithPath("title").description("The title of the vulnerability"),
                                fieldWithPath("description").description("The vulnerability description"),
                                fieldWithPath("externalId").description("The external Id"),
                                fieldWithPath("cwe").description("The CWE (Common Weakness Enumeration) value"),
                                fieldWithPath("publishDate").description("The publish date of the vulnerability"),
                                fieldWithPath("lastExternalUpdate").description("The last external update of the vulnerability"),
                                fieldWithPath("priority").description("The priority of vulnerability"),
                                fieldWithPath("priorityText").description("The priority text of vulnerability"),
                                subsectionWithPath("access").description("The access value of the vulnerability"),
                                subsectionWithPath("impact").description("The impact of the vulnerability"),
                                fieldWithPath("action").description("The action needs to be taken to resolve vulnerability"),
                                fieldWithPath("legalNotice").description("The legal notice of the vulnerability"),
                                fieldWithPath("assignedExtComponentIds").description("The assignedExtComponentIds for the vulnerability"),
                                fieldWithPath("extendedDescription").description("The extended description of the vulnerability"),
                                fieldWithPath("cvss").description("The cvss value of the vulnerability"),
                                fieldWithPath("cvssTime").description("The cvss time of the vulnerability"),
                                fieldWithPath("cveReferences").description("The cve references for the vulnerability"),
                                fieldWithPath("cveReferences[]year").description("The cve references year for the vulnerability"),
                                fieldWithPath("cveReferences[]number").description("The cve references number for the vulnerability"),
                                fieldWithPath("vendorAdvisories").description("The vendor advisories for the vulnerability"),
                                fieldWithPath("vendorAdvisories[]vendor").description("The vendor of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]name").description("The name of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]url").description("The url of vendor advisories"),
                                fieldWithPath("references").description("The references for the vulnerability"),
                                subsectionWithPath("vulnerableConfiguration").description("The vulnerable configuration of the vulnerability"),
                                subsectionWithPath("cveFurtherMetaDataPerSource").description("The cve further metadata per source of the vulnerability")
                        ),
                        responseFields(
                                fieldWithPath("title").description("The title of the vulnerability"),
                                fieldWithPath("description").description("The vulnerability description"),
                                fieldWithPath("externalId").description("The external Id"),
                                fieldWithPath("cwe").description("The CWE (Common Weakness Enumeration) value"),
                                fieldWithPath("publishDate").description("The publish date of the vulnerability"),
                                fieldWithPath("lastExternalUpdate").description("The last external update of the vulnerability"),
                                fieldWithPath("priority").description("The priority of vulnerability"),
                                fieldWithPath("priorityText").description("The priority text of vulnerability"),
                                subsectionWithPath("access").description("The access value of the vulnerability"),
                                subsectionWithPath("impact").description("The impact of the vulnerability"),
                                fieldWithPath("action").description("The action needs to be taken to resolve vulnerability"),
                                fieldWithPath("legalNotice").description("The legal notice of the vulnerability"),
                                fieldWithPath("assignedExtComponentIds").description("The assignedExtComponentIds for the vulnerability"),
                                fieldWithPath("extendedDescription").description("The extended description of the vulnerability"),
                                fieldWithPath("cvss").description("The cvss value of the vulnerability"),
                                fieldWithPath("cvssTime").description("The cvss time of the vulnerability"),
                                fieldWithPath("cveReferences").description("The cve references for the vulnerability"),
                                fieldWithPath("cveReferences[]year").description("The cve references year for the vulnerability"),
                                fieldWithPath("cveReferences[]number").description("The cve references number for the vulnerability"),
                                fieldWithPath("vendorAdvisories").description("The vendor advisories for the vulnerability"),
                                fieldWithPath("vendorAdvisories[]vendor").description("The vendor of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]name").description("The name of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]url").description("The url of vendor advisories"),
                                fieldWithPath("references").description("The references for the vulnerability"),
                                subsectionWithPath("vulnerableConfiguration").description("The vulnerable configuration of the vulnerability"),
                                subsectionWithPath("cveFurtherMetaDataPerSource").description("The cve further metadata per source of the vulnerability")
                        )));
    }

    @Test
    public void should_document_update_vulnerability() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(patch("/api/vulnerabilities/" + vulnerability4.getExternalId())
                .header("Authorization", "Bearer " + accessToken)
                .contentType(MediaTypes.HAL_JSON)
                .content(mapper.writeValueAsString(vulnerability4))
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isCreated())
                .andDo(this.documentationHandler.document(
                        requestFields(
                                fieldWithPath("title").description("The title of the vulnerability"),
                                fieldWithPath("description").description("The vulnerability description"),
                                fieldWithPath("externalId").description("The external Id"),
                                fieldWithPath("cwe").description("The CWE (Common Weakness Enumeration) value"),
                                fieldWithPath("publishDate").description("The publish date of the vulnerability"),
                                fieldWithPath("lastExternalUpdate").description("The last external update of the vulnerability"),
                                fieldWithPath("priority").description("The priority of vulnerability"),
                                fieldWithPath("priorityText").description("The priority text of vulnerability"),
                                subsectionWithPath("access").description("The access value of the vulnerability"),
                                subsectionWithPath("impact").description("The impact of the vulnerability"),
                                fieldWithPath("action").description("The action needs to be taken to resolve vulnerability"),
                                fieldWithPath("legalNotice").description("The legal notice of the vulnerability"),
                                fieldWithPath("assignedExtComponentIds").description("The assignedExtComponentIds for the vulnerability"),
                                fieldWithPath("extendedDescription").description("The extended description of the vulnerability"),
                                fieldWithPath("cvss").description("The cvss value of the vulnerability"),
                                fieldWithPath("cvssTime").description("The cvss time of the vulnerability"),
                                fieldWithPath("cveReferences").description("The cve references for the vulnerability"),
                                fieldWithPath("cveReferences[]year").description("The cve references year for the vulnerability"),
                                fieldWithPath("cveReferences[]number").description("The cve references number for the vulnerability"),
                                fieldWithPath("vendorAdvisories").description("The vendor advisories for the vulnerability"),
                                fieldWithPath("vendorAdvisories[]vendor").description("The vendor of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]name").description("The name of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]url").description("The url of vendor advisories"),
                                fieldWithPath("references").description("The references for the vulnerability"),
                                subsectionWithPath("vulnerableConfiguration").description("The vulnerable configuration of the vulnerability"),
                                subsectionWithPath("cveFurtherMetaDataPerSource").description("The cve further metadata per source of the vulnerability")
                        ),
                        responseFields(
                                fieldWithPath("title").description("The title of the vulnerability"),
                                fieldWithPath("description").description("The vulnerability description"),
                                fieldWithPath("externalId").description("The external Id"),
                                fieldWithPath("cwe").description("The CWE (Common Weakness Enumeration) value"),
                                fieldWithPath("publishDate").description("The publish date of the vulnerability"),
                                fieldWithPath("lastExternalUpdate").description("The last external update of the vulnerability"),
                                fieldWithPath("priority").description("The priority of vulnerability"),
                                fieldWithPath("priorityText").description("The priority text of vulnerability"),
                                subsectionWithPath("access").description("The access value of the vulnerability"),
                                subsectionWithPath("impact").description("The impact of the vulnerability"),
                                fieldWithPath("action").description("The action needs to be taken to resolve vulnerability"),
                                fieldWithPath("legalNotice").description("The legal notice of the vulnerability"),
                                fieldWithPath("assignedExtComponentIds").description("The assignedExtComponentIds for the vulnerability"),
                                fieldWithPath("extendedDescription").description("The extended description of the vulnerability"),
                                fieldWithPath("cvss").description("The cvss value of the vulnerability"),
                                fieldWithPath("cvssTime").description("The cvss time of the vulnerability"),
                                fieldWithPath("cveReferences").description("The cve references for the vulnerability"),
                                fieldWithPath("cveReferences[]year").description("The cve references year for the vulnerability"),
                                fieldWithPath("cveReferences[]number").description("The cve references number for the vulnerability"),
                                fieldWithPath("vendorAdvisories").description("The vendor advisories for the vulnerability"),
                                fieldWithPath("vendorAdvisories[]vendor").description("The vendor of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]name").description("The name of vendor advisories"),
                                fieldWithPath("vendorAdvisories[]url").description("The url of vendor advisories"),
                                fieldWithPath("references").description("The references for the vulnerability"),
                                subsectionWithPath("vulnerableConfiguration").description("The vulnerable configuration of the vulnerability"),
                                subsectionWithPath("cveFurtherMetaDataPerSource").description("The cve further metadata per source of the vulnerability")
                        )));
    }

    @Test
    public void should_document_delete_vulnerability() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(delete("/api/vulnerabilities/" + vulnerability.getExternalId())
                .header("Authorization", "Bearer " + accessToken)
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isMultiStatus())
                .andDo(this.documentationHandler.document(
                        responseFields(
                                fieldWithPath("[].resourceId").description("id of the deleted resource"),
                                fieldWithPath("[].status").description("status of the delete operation")
                        )
                ));
    }

    @Test
    public void should_document_delete_release_vulnerability_relation() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(delete("/api/vulnerabilities/" + vulnerability4.getExternalId() + "/release/1234")
                .header("Authorization", "Bearer " + accessToken)
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isMultiStatus())
                .andDo(this.documentationHandler.document(
                        responseFields(
                                fieldWithPath("[].resourceId").description("id of the deleted resources"),
                                fieldWithPath("[].status").description("status of the delete operation")
                        )
                ));
    }

    @Test
    public void should_document_create_release_vulnerability_relation() throws Exception {
        String accessToken = TestHelper.getAccessToken(mockMvc, testUserId, testUserPassword);
        mockMvc.perform(post("/api/vulnerabilities/" + vulnerability5.getExternalId() + "/releaseVulnerabilityRelation")
                .header("Authorization", "Bearer " + accessToken)
                .contentType(MediaTypes.HAL_JSON)
                .content(this.objectMapper.writeValueAsString(releaseVulnerabilityRelation))
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isOk())
                .andDo(this.documentationHandler.document(
                        requestFields(
                                fieldWithPath("releaseId").description("The id of the release"),
                                fieldWithPath("verificationStateInfo").description("The verification state info"),
                                fieldWithPath("verificationStateInfo[]checkedOn").description("The verification state checked on"),
                                fieldWithPath("verificationStateInfo[]checkedBy").description("The verification state checked by"),
                                fieldWithPath("verificationStateInfo[]comment").description("The verification state comment"),
                                fieldWithPath("verificationStateInfo[]verificationState").description("The verification state. Possible Value - " + Arrays.asList(VerificationState.values())),
                                fieldWithPath("matchedBy").description("The matched by value"),
                                fieldWithPath("usedNeedle").description("The used needle")
                        ),
                        responseFields(
                                fieldWithPath("releaseId").description("The id of the release"),
                                fieldWithPath("vulnerabilityId").description("The id of the vulnerability"),
                                fieldWithPath("verificationStateInfo").description("The verification state info"),
                                fieldWithPath("verificationStateInfo[]checkedOn").description("The verification state checked on"),
                                fieldWithPath("verificationStateInfo[]checkedBy").description("The verification state checked by"),
                                fieldWithPath("verificationStateInfo[]comment").description("The verification state comment"),
                                fieldWithPath("verificationStateInfo[]verificationState").description("The verification state. Possible Value - " + Arrays.asList(VerificationState.values())),
                                fieldWithPath("matchedBy").description("The matched by value"),
                                fieldWithPath("usedNeedle").description("The used needle")
                        )));
    }
}
